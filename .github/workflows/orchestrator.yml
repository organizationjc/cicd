name: Orchestrator (Java CI/CD Pro)

on:
  workflow_call:
    inputs:
      pipeline_profile:
        type: string
        required: true
      extra-vars:
        description: 'JSON string for overriding profile settings'
        type: string
        required: false
        default: '{}'

permissions:
  contents: read
  id-token: write
  packages: read
  security-events: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  IMAGE_BASENAME: ${{ inputs.image-name || github.repository }}

defaults:
  run:
    shell: bash

jobs:
  setup-config:
    runs-on: ubuntu-latest
    outputs:
      # ESTO SE QUEDA IGUAL. Define los outputs del JOB.
      do_image: ${{ fromJson(steps.config.outputs.cfg_json).switches.do_image }}
      java-version: ${{ fromJson(steps.config.outputs.cfg_json).java-version }}
      sonar-project-key: ${{ fromJson(steps.config.outputs.cfg_json).sonar.project-key }}
      runs-on: ${{ fromJson(steps.config.outputs.cfg_json).runs-on }}
      build-system: ${{ fromJson(steps.config.outputs.cfg_json).build-system }}
      project-name: ${{ fromJson(steps.config.outputs.cfg_json).project-name }}
      # ... (etc)

    steps:
      - name: Checkout Repository (for script)
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository }}
      
      - id: config
        run: |
          # 1. Ejecuta el script externo y captura su salida (stdout)
          JSON_OUTPUT=$(bash .github/scripts/get-merged-config.sh \
            "${{ inputs.pipeline_profile }}" \
            '${{ inputs.extra-vars }}')
          
          # 2. Pasa esa salida al GITHUB_OUTPUT para que los 'outputs' del job funcionen
          echo "cfg_json=$JSON_OUTPUT" >> $GITHUB_OUTPUT

  # ---------- Jobs que llaman reusables (SOLO 'uses' + 'with') ----------
  build:
    needs: setup-config
    uses: ./.github/workflows/1-build-java.yml
    with:
      runs-on: ${{ inputs.runs-on }}
      build-system: ${{ inputs.build-system }}
      java-version: ${{ inputs.java-version }}
      project-name: ${{ inputs.project-name }}

  unit-tests:
    needs: build
    uses: ./.github/workflows/2-test-unit.yml
    with:
      runs-on: ${{ inputs.runs-on }}
      build-system: ${{ inputs.build-system }}
      java-version: ${{ inputs.java-version }}

  integration-tests:
    needs: unit-tests
    uses: ./.github/workflows/2-test-integration.yml
    with:
      runs-on: ${{ inputs.runs-on }}
      build-system: ${{ inputs.build-system }}
      java-version: ${{ inputs.java-version }}

  static-analysis:
    needs: integration-tests
    uses: ./.github/workflows/3-static-checks.yml
    with:
      runs-on: ${{ inputs.runs-on }}
      build-system: ${{ inputs.build-system }}
      java-version: ${{ inputs.java-version }}

  sonarcloud:
    if: ${{ inputs.sonar-enabled && inputs.sonar-project-key != '' }}
    needs: static-analysis
    uses: ./.github/workflows/3-sonarcloud.yml
    with:
      runs-on: ${{ inputs.runs-on }}
      build-system: ${{ inputs.build-system }}
      java-version: ${{ inputs.java-version }}
      sonar-org: ${{ inputs.sonar-org }}
      sonar-project-key: ${{ inputs.sonar-project-key }}
      use-binaries-artifact: true
      # coverage-report-paths: '**/target/site/jacoco/*.xml,**/build/reports/jacoco/test/jacocoTestReport.xml'
      # wait-for-quality-gate: true
    secrets: inherit


  snyk-scan:
    if: ${{ inputs.snyk-enabled }}
    needs: static-analysis
    uses: ./.github/workflows/3-snyk-scan.yml
    with:
      runs-on: ${{ inputs.runs-on }}
      build-system: ${{ inputs.build-system }}
      java-version: ${{ inputs.java-version }}
      severity-threshold: ${{ inputs.snyk-severity-threshold }}
      use-docker-action: true
      jdk-major: '17'
      snyk-slug: ${{ inputs.snyk-slug }}
    secrets: inherit

  jfrog-xray:
    if: ${{ inputs.jfrog-enabled && inputs.jfrog-server-url != '' }}
    needs: static-analysis
    uses: ./.github/workflows/3-jfrog-xray.yml
    with:
      runs-on: ${{ inputs.runs-on }}
      jfrog-server-url: ${{ inputs.jfrog-server-url }}
      jfrog-repo: ${{ inputs.jfrog-repo }}
      build-name: ${{ inputs.jfrog-build-name }}
      build-number: ${{ inputs.jfrog-build-number }}
    secrets: inherit

  image-build:
    if: ${{ needs.set-switches.outputs.do_image == 'true' }}
    #needs: [static-analysis, sonarcloud, snyk-scan, resolve-image-ref]
    needs: [jfrog-xray]
    uses: ./.github/workflows/4-image-build.yml
    with:
      runs-on: ${{ inputs.runs-on }}
      dockerfile-path: ${{ inputs.dockerfile-path }}
      image-name: ${{ inputs.image-name || github.repository }}

  image-scan:
    if: ${{ inputs.run-trivy && needs.set-switches.outputs.do_image == 'true' }}
    needs: image-build
    uses: ./.github/workflows/3-image-scan-trivy.yml
    with:
      image-ref: ${{ needs.image-build.outputs.image-tag }}

  sign-image:
    if: ${{ needs.set-switches.outputs.do_image == 'true' }}
    needs: image-scan
    uses: ./.github/workflows/4-sign-cosign.yml
    with:
      image-ref: ${{ needs.image-build.outputs.image-tag }}
    secrets: inherit

  push-image:
    if: ${{ needs.set-switches.outputs.do_image == 'true' }}
    needs: sign-image
    permissions: { contents: read, packages: write, id-token: write }
    uses: ./.github/workflows/4-image-push.yml
    with:
      runs-on: ${{ inputs.runs-on }}
      image-ref: ${{ needs.image-build.outputs.image-tag }}
      registry-server: ${{ inputs.registry-server }}
      registry-namespace: ${{ inputs.registry-namespace }}
    secrets: inherit

  # ---------- Job “normal” para Tomcat (con steps) ----------
  deploy-tomcat:
    if: ${{ needs.set-switches.outputs.do_deploy_tomcat == 'true' }}
    #needs: [static-analysis, snyk-scan, sonarcloud]
    needs: [static-analysis]
    uses: ./.github/workflows/5-deploy-tomcat-ssh.yml
    with:
      runs-on: ${{ inputs.runs-on }}
      tomcat-artifact-name: mi-app-tomcat-war
      tomcat-webapps-path: /var/lib/tomcat9/webapps   # <— CAMBIA AQUÍ
      target-war-name: app.war                         # o ROOT.war si quieres desplegar en /
      tomcat-service-name: tomcat9                     # <— CAMBIA AQUÍ
    secrets:
      # Mapping: <child_secret> : <secret_received_by_orchestrator>
      TOMCAT_SSH_HOST: ${{ secrets.TOMCAT_SSH_HOST }}
      TOMCAT_SSH_USER: ${{ secrets.TOMCAT_SSH_USER }}
      TOMCAT_SSH_KEY: ${{ secrets.TOMCAT_SSH_KEY }}

      # - name: Deploy via SSH (optional)
      #   if: ${{ inputs.use_ssh_deploy == 'true' }}
      #   uses: ./.github/actions/tomcat-ssh-deploy
      #   with:
      #     host: ${{ secrets.TOMCAT_SSH_HOST }}
      #     user: ${{ secrets.TOMCAT_SSH_USER }}
      #     key: ${{ secrets.TOMCAT_SSH_KEY }}
      #     war: ./artifact/${{ inputs.tomcat-artifact-name }}
      #     remote_webapps: /opt/tomcat/webapps

      # - name: Deploy via Tomcat Manager
      #   if: ${{ inputs.use_ssh_deploy != 'true' }}
      #   run: |
      #     curl -u "${{ secrets.TOMCAT_USER }}:${{ secrets.TOMCAT_PASSWORD }}" \
      #       --upload-file "./artifact/${{ inputs.tomcat-artifact-name }}" \
      #       "${{ inputs.tomcat-url }}/manager/text/deploy?path=${{ inputs.tomcat-context }}&update=true"

  # summarize:
  #   needs: [push-image, deploy-tomcat]
  #   if: always()
  #   runs-on: ${{ inputs.runs-on }}
  #   steps:
  #     - run: |
  #         echo "## Run Summary" >> $GITHUB_STEP_SUMMARY
  #         echo "- Sonar: enabled=${{ inputs.sonar-enabled }} org=${{ inputs.sonar-org }} project=${{ inputs.sonar-project-key }}" >> $GITHUB_STEP_SUMMARY
  #         echo "- Snyk: enabled=${{ inputs.snyk-enabled }} threshold=${{ inputs.snyk-severity-threshold }}" >> $GITHUB_STEP_SUMMARY
  #         echo "- JFrog: enabled=${{ inputs.jfrog-enabled }} url=${{ inputs.jfrog-server-url }} repo=${{ inputs.jfrog-repo }}" >> $GITHUB_STEP_SUMMARY
